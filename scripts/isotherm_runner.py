# This script performs multiple DL_MONTE simulations to calculate the mean and uncertainty in the energy and number
# of molecules in the system automatically generated by other python scripts in this directory as a function of
# pressure. The simulations used to calculate the mean and uncertainty at each fugacity are constrained for
# convenience to take 30 seconds. The 13 fugacities from 0.5 Pa to 40 Pa (inclusive);
# thus this script should take about 600s = 10 mins to complete.

import logging

import dlmontepython.simtask.dlmonteinterface as interface
import dlmontepython.simtask.measurement as measurement
import dlmontepython.simtask.task as task
import isotherm_control_generator as isotherm
import cif2config as c2c
from glob import glob

# Set up the logger, which determines the nature of information output by the machinery in the 'task' package.
# The code below results in logging information being output to stdout

handler = logging.StreamHandler()

# Replacing 'logging.INFO' with 'logging.DEBUGGING' below results in more information being output by the
# logger. Using 'logging.WARNING' results in less information being output: only 'warnings'

measurement.logger.setLevel(logging.DEBUG)
measurement.logger.addHandler(handler)


# Set up the CONTROL input file from the example in isotherm.py.

control_obj = isotherm.AdsorptionExample
control_obj.use_block.use_statements.pop('ortho')
control_obj.main_block.statements['noewald'] = 'all'
with open('./CONTROL', 'w') as f:
    f.write(str(control_obj))

# Set up the FIELD and CONFIG files from the generator in cif2config.

infile = 'Cu_BTC'

print(infile)
c2c.create_config_field(infile, input_directory='interface/', output_directory='')

# Set up the relevant TaskInterface object: which tells the low-level machinery in the 'task' package
# which code will be used to perform the simulations, and how to perform various tasks specific to that
# code, e.g. extracting the energy from output files created by the code.
# In this case we use DL_MONTE to perform our simulations; thus the TaskInterface object we will use
# is in fact a DLMonteInterface object (DLMonteInterface is a subclass of TaskInterface). The line
# below sets up a DL_MONTE-specific interface. Note that the interface must know the location of the 
# DL_MONTE executable - which is specified as the argument to the DLMonteInterface constructor.

interface = interface.DLMonteInterface("/usr/local/bin/DLMONTE-SRL.X")

# Set up a list of 'observables' to track and analyse. Observables must be Observable objects, and the nature
# of Observable objects may vary between simulation codes. For DL_MONTE only observables corresponding to variables
# output periodically in YAMLDATA are currently supported. For a variable 'foo' specified in the YAMLDATA file
# the corresponding Observable object is returned by the command 'task.Observable( ("foo",) )'. Note the essential
# comma after "foo"! For a variable in YAMLDATA which is an array (e.g., 'nmol'), the observable corresponding to 
# the nth element in the array is returned by the command 'task.Observable( ("foo",n-1) )'. See below: 'energy_obs'
# corresponds to the 'energy' variable in YAMLDATA, and 'nmol_obs' corresponds to the 1st element in the 'nmol'
# array in YAMLDATA (which in fact is the number of molecules belonging to the 1st molecular species)

energy_obs = task.Observable( ("energy",) )
nmol_obs = task.Observable( ("nmol",1) )
observables = [ energy_obs, nmol_obs ]

# Set up a dictionary containing the threshold precisions to which to determine the observables. Here we only
# specify a threshold precision for the energy observable: the simulations will terminate when the energy is
# determined to an uncertainty less than 0.2 (energy units).

precisions = { nmol_obs : 2 }

# Set up a Measurement object which will determine the nature of the simulations and data analysis at each
# temperature. We specify that no more than 20 simulations will be performed (via the 'maxsims' argument), and
# that the maximum time we will allow over all simulations at a given temperature is 300s (via the 'maxtime' 
# argument).

measurement_template = measurement.Measurement(interface, observables, precisions=precisions, maxsims=20, maxtime=600)

# Set up the list of temperatures to consider

molchempots = [1e-15, 1e-14, 1e-13, 1e-12, 1e-11, 1e-10, 1e-9, 1e-8, 1e-7, 1e-6, 1e-5, 1e-4, 1e-3, 1e-2]

# Set up a MeasurementSweep object which - which will actually perform the simulations and data analysis.
# Note that all the simulations and output files pertaining to analysis will be created in the directory
# 'fixedtimesweep' (via the 'outputdir' argument). Note also that the control parameter 'param' is set to 
# "temperature" while the list of control parameters to explore 'paramvalues' is set to the the temperatures
# mentioned above. The DLMonteInterface, linked to the MeasurementSweep object via 'interface' in 
# 'measurement_template', thus knows to treat the temperature in the CONTROL file as a control parameter, 
# and explore the temperatures in 'temperatures' accordingly

sweep = measurement.MeasurementSweep(param="molchempot", paramvalues=molchempots, 
                                     measurement_template=measurement_template, outputdir="bounds_scan")

# Run the task

sweep.run()

import matplotlib.pyplot as plt
import pandas as pd

data = pd.read_csv('./bounds_scan/nmol_1_sweep.dat', sep=' ', header=None, names=['Fugacity (katm)', 'Quantity adsorbed (mol/uc)', 'Uncertainty'])

plt.errorbar(data['Fugacity (katm)'], data['Quantity adsorbed (mol/uc)'], data['Uncertainty'], marker='.')
plt.xlabel('Fugacity (katm)')
plt.ylabel('Quantity adsorbed (mol/uc)')
plt.xscale('log')
plt.savefig('../interface/bounds_scan.png')
plt.clf()

data.to_csv('../interface/simulation_data.csv', sep=',', index=False)

print('Script complete!')


