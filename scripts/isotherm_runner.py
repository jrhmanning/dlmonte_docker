# This script performs multiple DL_MONTE simulations to calculate the mean and uncertainty in the energy and number
# of molecules in the system automatically generated by other python scripts in this directory as a function of
# pressure. The simulations used to calculate the mean and uncertainty at each fugacity are constrained for
# convenience to take 600 seconds. The 14 fugacities span orders of magnitutde from 1e-7 to 1e6 Pa (inclusive);
# thus this script should act as a rough scan of an isotherm to guide more precise points in a second scan.
# The whole script should take ca. 45 minutes to complete.

import logging
import os
import dlmontepython.simtask.dlmonteinterface as interface
import dlmontepython.simtask.measurement as measurement
import dlmontepython.simtask.task as task
import dlmontepython.htk.sources.dlconfig as config
import isotherm_control_generator as isotherm
import cif2config as c2c
from glob import glob
import argparse
import pathlib
import json
import sorbates
from typing import Union

def Pa_to_katm(pressure: float) -> float:
    try:
        float(pressure)
    except TypeError:
        raise TypeError('Impossible to parse pressure values as floats!')
    return pressure*9.86923e-9

def str_to_floats(input_string: str) -> list:
    return [float(x) for x in input_string.split(',')]

def pressure_preprocess(input_string: str) -> list:
    return [Pa_to_katm(x) for x in str_to_floats(input_string)]

def composition_preprocess(input_string:str) -> dict:
    return json.loads(eval(input_string))

def parse_input_file(input_name: str) -> Union[str,config.CONFIG]:
    # flexibly parses input file information to handle empty cells
    try:
        boxsize = float(input_name)
        config.CONFIG(
            title="Empty cubic cell",
            level=1,
            dlformat=0,
            vcell=[boxsize,boxsize,boxsize],
            nummol=0,
            molecules=0
        )
        return None
    except:
        return None
# Set up the logger, which determines the nature of information output by the machinery in the 'task' package.
# The code below results in logging information being output to stdout

handler = logging.StreamHandler()

# Replacing 'logging.INFO' with 'logging.DEBUGGING' below results in more information being output by the
# logger. Using 'logging.WARNING' results in less information being output: only 'warnings'

measurement.logger.setLevel(logging.INFO)
measurement.logger.addHandler(handler)

# Define external arguments for file input/output locations

parser = argparse.ArgumentParser()
parser.add_argument('-i','--InputFolder',
                    type=str,
                    action='store',
                    required=False,
                    metavar='INPUT_FOLDER',
                    default='.',
                    help='Location of the framework CIF files.')

parser.add_argument('-o','--OutputFolder',
                    type=str,
                    action='store',
                    required=False,
                    metavar='OUTPUT_FOLDER',
                    default='.',
                    help='Intended location for output files.')

parser.add_argument('-f','--FrameworkName',
                    type=str,
                    action='store',
                    required=True,
                    metavar='FRAMEWORK_NAME',
                    help='Name of the framework used (and associated .cif file).')

parser.add_argument('-c', '--GasComposition',
                    action='store',
                    type=eval,
                    required=False,
                    default='{"CO2": 1.0}',
                    metavar='GAS_COMPOSITION',
                    help="Gas composition, as a string json object (e.g. '{\"CO2\": 1.0}').")

parser.add_argument('-t','--Temperature',
                    type=float,
                    action='store',
                    required=False,
                    metavar='TEMPERATURE',
                    default=298.0,
                    help='Specified temperature (in K).')

parser.add_argument('-p','--Pressures',
                    action='store',
                    required=False,
                    metavar='PRESSURES',
                    type=pressure_preprocess,
                    default='1e-2,1e-1,1e0,1e1,1e2,1e3,1e4,1e5,1e6',
                    help='Specified pressures in Pa as comma-separates string (e.g. \"1,2\").')

parser.add_argument('-q', '--Charges',
                    action='store',
                    required=False,
                    metavar='CHARGES',
                    type=bool,
                    default=True,
                    help='Ewald summation charges - set to False to turn off charges')
args = parser.parse_args()

logging.debug(args)

# Now let's set up the paths to the input and output directories, and check they exist
input_file = pathlib.Path(args.InputFolder,  args.FrameworkName).with_suffix('.cif')
assert input_file.exists(), '''Cannot find input file from specified location: {0}
current directory: {1}
{2}
input directory: {3}
{4}'''.format(input_file, os.getcwd(), os.listdir(), args.InputFolder, os.listdir(args.InputFolder))

output_folder = pathlib.Path(args.OutputFolder)
output_folder.mkdir(parents=True, exist_ok=True) # Makes the directory, if it didn't already exist

logging.info(f"""-------------------
Beginning Automated isotherm simulation
-------------------
Meta-variables:
-------------------
Input folder: {args.InputFolder}
Output folder: {args.OutputFolder}
Simulation framework: {args.FrameworkName}
Simulation temperature: {args.Temperature}
Simulation composition: {args.GasComposition} (N.B. gas pressures will only change for the first species)
Simulation pressures (in Pa): {args.Pressures}
-------------------
""")


# Set up the CONTROL input file from the example in isotherm.py.
control_location = pathlib.Path('/run/CONTROL')

control_obj = isotherm.AdsorptionExample
control_obj.use_block.use_statements.pop('ortho')
if not args.Charges:
    control_obj.main_block.statements['noewald'] = 'all'

control_obj.main_block.statements['temperature'] = args.Temperature

control_obj.main_block.moves = isotherm.define_molecule_movers(list(args.GasComposition.keys())[0])
with open(control_location, 'w') as f:
    f.write(str(control_obj))

# Set up the FIELD and CONFIG files from the generator in cif2config.
#TODO: add multiple sorbate functionality
config_field_location = pathlib.Path('/run/')
c2c.create_config_field(input_file=input_file,
                        output_directory=config_field_location,
                        use_cif_hack=True,
                        sorbate_molecules=[sorbates.lookup[list(args.GasComposition.keys())[0]]])

# DEBUG: print out the locations of the input files

print(f'Control file at {control_location} exists? {control_location.exists()}')
config_location = config_field_location / 'CONFIG'
print(f'Config file at {config_location} exists? {config_location.exists()}')
field_location = config_field_location / 'FIELD'
print(f'Field file at {field_location} exists? {field_location.exists()}')

# Set up the relevant TaskInterface object: which tells the low-level machinery in the 'task' package
# which code will be used to perform the simulations, and how to perform various tasks specific to that
# code, e.g. extracting the energy from output files created by the code.
# In this case we use DL_MONTE to perform our simulations; thus the TaskInterface object we will use
# is in fact a DLMonteInterface object (DLMonteInterface is a subclass of TaskInterface). The line
# below sets up a DL_MONTE-specific interface. Note that the interface must know the location of the 
# DL_MONTE executable - which is specified as the argument to the DLMonteInterface constructor.

interface = interface.DLMonteInterface("/usr/local/bin/DLMONTE-SRL.X")

# Set up a list of 'observables' to track and analyse. Observables must be Observable objects, and the nature
# of Observable objects may vary between simulation codes. For DL_MONTE only observables corresponding to variables
# output periodically in YAMLDATA are currently supported. For a variable 'foo' specified in the YAMLDATA file
# the corresponding Observable object is returned by the command 'task.Observable( ("foo",) )'. Note the essential
# comma after "foo"! For a variable in YAMLDATA which is an array (e.g., 'nmol'), the observable corresponding to 
# the nth element in the array is returned by the command 'task.Observable( ("foo",n-1) )'. See below: 'energy_obs'
# corresponds to the 'energy' variable in YAMLDATA, and 'nmol_obs' corresponds to the 1st element in the 'nmol'
# array in YAMLDATA (which in fact is the number of molecules belonging to the 1st molecular species)

energy_obs = task.Observable( ("energy",) )
nmol_obs = task.Observable( ("nmol",1) )
observables = [ energy_obs, nmol_obs ]

# Set up a dictionary containing the threshold precisions to which to determine the observables. Here we only
# specify a threshold precision for the energy observable: the simulations will terminate when the energy is
# determined to an uncertainty less than 0.2 (energy units).

precisions = { nmol_obs : 2 }

# Set up a Measurement object which will determine the nature of the simulations and data analysis at each
# temperature. We specify that no more than 20 simulations will be performed (via the 'maxsims' argument), and
# that the maximum time we will allow over all simulations at a given temperature is 600s (via the 'maxtime'
# argument).

measurement_template = measurement.Measurement(interface, observables, precisions=precisions, maxsims=20, maxtime=600)

# Set up the list of temperatures to consider

molchempots = args.Pressures

# Set up a MeasurementSweep object which - which will actually perform the simulations and data analysis.
# Note that all the simulations and output files pertaining to analysis will be created in the directory
# 'bounds_scan' (via the 'outputdir' argument). Note also that the control parameter 'param' is set to
# "molchempot" while the list of control parameters to explore 'paramvalues' is set to the fugacities
# mentioned above. The DLMonteInterface, linked to the MeasurementSweep object via 'interface' in 
# 'measurement_template', thus knows to treat the fugacity in the CONTROL file as a control parameter,
# and explore the temperatures in 'molchempots' accordingly

sweep = measurement.MeasurementSweep(param="molchempot", paramvalues=molchempots, 
                                     measurement_template=measurement_template, outputdir="bounds_scan")

# Run the task

sweep.run()

import matplotlib.pyplot as plt
import pandas as pd

data = pd.read_csv(pathlib.Path('/run/bounds_scan/nmol_1_sweep.dat'),
                   sep=' ',
                   header=None,
                   names=['Fugacity (katm)', 'Quantity adsorbed (mol/uc)', 'Uncertainty']
                   )

plt.errorbar(data['Fugacity (katm)'], data['Quantity adsorbed (mol/uc)'], data['Uncertainty'], marker='.')
plt.xlabel('Fugacity (katm)')
plt.ylabel('Quantity adsorbed (mol/uc)')
plt.xscale('log')
plt.savefig(output_folder / 'bounds_scan.png')
plt.clf()


data.to_csv(output_folder / 'simulation_data.csv', sep=',', index=False)

print('Script complete!')


