# This script performs multiple DL_MONTE simulations to calculate the mean and uncertainty in the energy and number
# of molecules in the system automatically generated by other python scripts in this directory as a function of
# pressure. The simulations used to calculate the mean and uncertainty at each fugacity are constrained for
# convenience to take 600 seconds. The 14 fugacities span orders of magnitutde from 1e-7 to 1e6 Pa (inclusive);
# thus this script should act as a rough scan of an isotherm to guide more precise points in a second scan.
# The whole script should take ca. 45 minutes to complete.

import logging
import os
import dlmontepython.simtask.dlmonteinterface as interface
import dlmontepython.simtask.measurement as measurement
import dlmontepython.simtask.task as task
import tarfile
from glob import glob
import argparse
import pathlib

from typing import Union

def Pa_to_katm(pressure: float) -> float:
    try:
        float(pressure)
    except TypeError:
        raise TypeError('Impossible to parse pressure values as floats!')
    return pressure*9.86923e-9

def str_to_floats(input_string: str) -> list:
    return [float(x) for x in input_string.split(',')]

def pressure_preprocess(input_string: str) -> list:
    return [Pa_to_katm(x) for x in str_to_floats(input_string)]

# Set up the logger, which determines the nature of information output by the machinery in the 'task' package.
# The code below results in logging information being output to stdout

handler = logging.StreamHandler()

# Replacing 'logging.INFO' with 'logging.DEBUGGING' below results in more information being output by the
# logger. Using 'logging.WARNING' results in less information being output: only 'warnings'

measurement.logger.setLevel(logging.INFO)
measurement.logger.addHandler(handler)

# Define external arguments for file input/output locations

parser = argparse.ArgumentParser()
parser.add_argument('-i','--InputFolder',
                    type=str,
                    action='store',
                    required=False,
                    metavar='INPUT_FOLDER',
                    default='.',
                    help='Location of the framework CIF files.')

parser.add_argument('-o','--OutputFolder',
                    type=str,
                    action='store',
                    required=False,
                    metavar='OUTPUT_FOLDER',
                    default='.',
                    help='Intended location for output files.')

parser.add_argument('-p','--Pressures',
                    action='store',
                    required=False,
                    metavar='PRESSURES',
                    type=pressure_preprocess,
                    default='1e-2,1e-1,1e0,1e1,1e2,1e3,1e4,1e5,1e6',
                    help='Specified pressures in Pa as comma-separates string (e.g. \"1,2\").')

args = parser.parse_args()

logging.debug(args)

output_folder = pathlib.Path(args.OutputFolder)
output_folder.mkdir(parents=True, exist_ok=True) # Makes the directory, if it didn't already exist

logging.info(f"""-------------------
Beginning Automated isotherm simulation
-------------------
Meta-variables:
-------------------
Input folder: {args.InputFolder}
Output folder: {args.OutputFolder}
Simulation pressures (in Pa): {args.Pressures}
-------------------
""")

with tarfile.open(f'{args.InputFolder}/dlm_preprocess.tgz', 'r:gz') as tar:
    try:
        tar.extract('CONTROL', path = args.InputFolder)
        tar.extract('CONFIG', path = args.InputFolder)
        tar.extract('FIELD', path = args.InputFolder)
    except KeyError:
        print(tar.getmembers())
        import sys
        sys.exit()


# Set up the relevant TaskInterface object: which tells the low-level machinery in the 'task' package
# which code will be used to perform the simulations, and how to perform various tasks specific to that
# code, e.g. extracting the energy from output files created by the code.
# In this case we use DL_MONTE to perform our simulations; thus the TaskInterface object we will use
# is in fact a DLMonteInterface object (DLMonteInterface is a subclass of TaskInterface). The line
# below sets up a DL_MONTE-specific interface. Note that the interface must know the location of the 
# DL_MONTE executable - which is specified as the argument to the DLMonteInterface constructor.

interface = interface.DLMonteInterface("/usr/local/bin/DLMONTE-SRL.X")

# Set up a list of 'observables' to track and analyse. Observables must be Observable objects, and the nature
# of Observable objects may vary between simulation codes. For DL_MONTE only observables corresponding to variables
# output periodically in YAMLDATA are currently supported. For a variable 'foo' specified in the YAMLDATA file
# the corresponding Observable object is returned by the command 'task.Observable( ("foo",) )'. Note the essential
# comma after "foo"! For a variable in YAMLDATA which is an array (e.g., 'nmol'), the observable corresponding to 
# the nth element in the array is returned by the command 'task.Observable( ("foo",n-1) )'. See below: 'energy_obs'
# corresponds to the 'energy' variable in YAMLDATA, and 'nmol_obs' corresponds to the 1st element in the 'nmol'
# array in YAMLDATA (which in fact is the number of molecules belonging to the 1st molecular species)

energy_obs = task.Observable( ("energy",) )
nmol_obs = task.Observable( ("nmol",1) )
observables = [ energy_obs, nmol_obs ]

# Set up a dictionary containing the threshold precisions to which to determine the observables. Here we only
# specify a threshold precision for the energy observable: the simulations will terminate when the energy is
# determined to an uncertainty less than 0.2 (energy units).

precisions = { nmol_obs : 2 }

# Set up a Measurement object which will determine the nature of the simulations and data analysis at each
# temperature. We specify that no more than 20 simulations will be performed (via the 'maxsims' argument), and
# that the maximum time we will allow over all simulations at a given temperature is 600s (via the 'maxtime'
# argument).

measurement_template = measurement.Measurement(interface, observables, precisions=precisions, maxsims=20, maxtime=600, inputdir = args.InputFolder)

# Set up the list of temperatures to consider

molchempots = args.Pressures

# Set up a MeasurementSweep object which - which will actually perform the simulations and data analysis.
# Note that all the simulations and output files pertaining to analysis will be created in the directory
# 'bounds_scan' (via the 'outputdir' argument). Note also that the control parameter 'param' is set to
# "molchempot" while the list of control parameters to explore 'paramvalues' is set to the fugacities
# mentioned above. The DLMonteInterface, linked to the MeasurementSweep object via 'interface' in 
# 'measurement_template', thus knows to treat the fugacity in the CONTROL file as a control parameter,
# and explore the temperatures in 'molchempots' accordingly

sweep = measurement.MeasurementSweep(param="molchempot", paramvalues=molchempots, 
                                     measurement_template=measurement_template, outputdir=args.OutputFolder)

# Run the task
logging.debug(sweep)

logging.info('Running sweep now...')

sweep.run()

# Add in some kind of result wrapper here!

print('Script complete!')


